<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦唉</title>
  <subtitle>azraa</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azraa.top/"/>
  <updated>2017-04-23T12:24:12.000Z</updated>
  <id>http://azraa.top/</id>
  
  <author>
    <name>Azraa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初学Python</title>
    <link href="http://azraa.top/2017/04/23/Python/"/>
    <id>http://azraa.top/2017/04/23/Python/</id>
    <published>2017-04-22T16:00:00.000Z</published>
    <updated>2017-04-23T12:24:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初学Python"><a href="#初学Python" class="headerlink" title="初学Python"></a>初学Python</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="最近由于项目需求需要去学习python这门语言，所以就自己在网上看了看廖雪峰大大的Python2-7教程-我个人觉得廖大大的教程看了之后还是很受益的。由于廖大写的已经跟详细了所以我就不一一赘述了这篇文章主要针对有开发经验的小伙伴们阅读使用。没接触过的小伙伴可以直接去看廖大的教程地址po给你们"><a href="#最近由于项目需求需要去学习python这门语言，所以就自己在网上看了看廖雪峰大大的Python2-7教程-我个人觉得廖大大的教程看了之后还是很受益的。由于廖大写的已经跟详细了所以我就不一一赘述了这篇文章主要针对有开发经验的小伙伴们阅读使用。没接触过的小伙伴可以直接去看廖大的教程地址po给你们" class="headerlink" title="最近由于项目需求需要去学习python这门语言，所以就自己在网上看了看廖雪峰大大的Python2.7教程 我个人觉得廖大大的教程看了之后还是很受益的。由于廖大写的已经跟详细了所以我就不一一赘述了这篇文章主要针对有开发经验的小伙伴们阅读使用。没接触过的小伙伴可以直接去看廖大的教程地址po给你们"></a>最近由于项目需求需要去学习python这门语言，所以就自己在网上看了看廖雪峰大大的Python2.7教程 我个人觉得廖大大的教程看了之后还是很受益的。由于廖大写的已经跟详细了所以我就不一一赘述了这篇文章主要针对有开发经验的小伙伴们阅读使用。没接触过的小伙伴可以直接去看廖大的教程地址po给你们</h3><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">Python 2.7教程</a></p>
<hr>
<h2 id="Python-的基本的输入和输出"><a href="#Python-的基本的输入和输出" class="headerlink" title="Python 的基本的输入和输出"></a>Python 的基本的输入和输出</h2><blockquote>
<p>在介绍输入和输出之前我们应该知道python要在哪里执行 第一种执行方式是打开cmd 并在cmd中输入<code>pthon</code> 之后会显示<code>&gt;&gt;&gt;</code>说明你已经进入了python的交互模式了。</p>
<p>在交互模式中直接输入<code>100+200</code>并计算结果就会显示</p>
</blockquote>
<pre><code class="python">&gt;&gt;&gt;100+200
300
</code></pre>
<blockquote>
<p>当你想要退出交互模式时只需要输入<code>exit()</code>就会退出交互模式</p>
<p>是不是特别简单~ 但是在交互模式下有一个问题 那就是不能保存代码 所以我们要用到第二种方式， 那就是运用编辑器去保存我们的代码，使用什么编辑器就看各人喜好了~</p>
<p>用编辑器保存时将代码保存成.py格式的文件 然后打开命令行窗口 运行就可以了。例如</p>
</blockquote>
<pre><code class="python">:C:\Workspace&gt;python hello.py
hello, world
</code></pre>
<blockquote>
<p>如果当前目录下没有hello.py这个文件的话那么运行<code>python hello.py</code>就会报错</p>
</blockquote>
<pre><code class="python">python hello.py
python: can&#39;t open file &#39;hello.py&#39;: [Errno 2] No such file or directory
</code></pre>
<hr>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>用<code>print</code>加上字符串就可以将指定的文字输出在屏幕上了,代码如下：</p>
</blockquote>
<pre><code class="python">&gt;&gt;&gt;print &#39;hello world&#39;
</code></pre>
<blockquote>
<p>当然<code>print</code>语句也可以输出多个字符串，字符串之间用‘，’隔开,例如：</p>
</blockquote>
<pre><code class="python">print &#39;my name is :&#39;,&#39;WS&#39;
&gt;&gt;&gt; my name is WS
</code></pre>
<hr>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>python提供了一个<code>raw_input</code>的方法可以让用户从电脑输入一些字符并且存放到一个变量里，就比如输入用户名称：</p>
<pre><code class="python">&gt;&gt;name=raw_input()
Miya
</code></pre>
<p>当你输入<code>name = raw_input()</code>并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。输入完成后，不会有任何提示，Python交互式命令行又回到<code>&gt;&gt;&gt;</code>状态了。那我们刚才输入的内容到哪去了？答案是存放到<code>name</code>变量里了。可以直接输入<code>name</code>查看变量内容：</p>
<pre><code class="python">&gt;&gt;name
&#39;Miya&#39;
</code></pre>
<p>这里我则不再多赘述变量是什么概念了</p>
<p>当然这样在程序运行的时候没有任何提示信息告诉用户，显得很不友好，所以我们可以这样写：</p>
<pre><code class="python">name = raw_input(&#39;please enter your name: &#39;)
</code></pre>
<p>这样在程序运行的时候,会首先打印出<code>please enter your name:</code>,这样用户就会根据提示输入名字。</p>
<pre><code class="python">C:\Workspace&gt; python hello.py
please enter your name: Miya
hello, Miya
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。</p>
<h2 id="输入是Input，输出是Output，因此，我们把输入输出统称为Input-Output，或者简写为IO。"><a href="#输入是Input，输出是Output，因此，我们把输入输出统称为Input-Output，或者简写为IO。" class="headerlink" title="输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。"></a>输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</h2></blockquote>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><blockquote>
<p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>字符串是以’’或””括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用””括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。<br>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<pre><code class="python">&#39;I\&#39;m \&quot;OK\&quot;!&#39;
</code></pre>
<p>表示的字符串内容是：</p>
<pre><code class="python">I&#39;m &quot;OK&quot;!
</code></pre>
</blockquote>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><blockquote>
<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等。</p>
</blockquote>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><blockquote>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p>
</blockquote>
<pre><code class="python">&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
&gt;&gt;&gt; 3 &gt; 2
True
&gt;&gt;&gt; 3 &gt; 5
False
</code></pre>
<blockquote>
<p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。<code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p>
<pre><code class="python">&gt;&gt; True and True
True
&gt;&gt; True and False
False
&gt;&gt; False and False
False
</code></pre>
<pre><code class="or```运算是或运算，只要其中有一个为```True```，```or```运算结果就是```True```：">```python
&gt;&gt; True or True
True
&gt;&gt; True or False
True
&gt;&gt; False or False
False
</code></pre>
<pre><code class="not```运算是非运算，它是一个单目运算符，把```True```变成```False```，```False```变成```True```：">```python
&gt;&gt; not True
False
&gt;&gt; not False
True
</code></pre>
<p>布尔值经常用在条件判断中，比如：</p>
<pre><code class="python">if age &gt;= 18:
    print &#39;adult&#39;
else:
    print &#39;teenager&#39;
</code></pre>
</blockquote>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><h2 id="gt-空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。"><a href="#gt-空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。" class="headerlink" title="&gt;空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。"></a>&gt;空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</h2><h2 id="list-和tuple"><a href="#list-和tuple" class="headerlink" title="list 和tuple"></a>list 和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><blockquote>
<p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。比如：</p>
<pre><code class="python">&gt;&gt;classmates=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]
&gt;&gt;classmates
[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]
</code></pre>
<p>变量<code>classmates</code>就是一个list。用<code>len()</code>函数可以获得list元素的个数：</p>
<pre><code class="python">&gt;&gt; len(classmates)
4
</code></pre>
<p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p>
<pre><code class="python">&gt;&gt; classmates[0]
&#39;a&#39;
&gt;&gt; classmates[1]
&#39;b&#39;
&gt;&gt; classmates[2]
&#39;c&#39;
&gt;&gt; classmates[3]
&#39;d&#39;
</code></pre>
<p>Python还内置了很多list的操作方法。<br>要删除list末尾的元素，用pop()方法。<br>要删除指定位置的元素，用pop(i)方法，其中i是索引位置。<br>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置等等。<br>可以将下面的代码段复制到自己的编辑器中在命令行中将程序跑起来你将会理解这些方法的作用:)  </p>
</blockquote>
<pre><code class="python">classmates=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]
print u&#39;这是新建的list：classmates===&#39;,classmates
classmates.pop()
print u&#39;这是使用pop方法后的classmates===&#39;,classmates
classmates.append(&#39;bbb&#39;)
print u&#39;这是使用append方法后的classmates===&#39;,classmates
classmates.insert(0,&#39;aaa&#39;)
print u&#39;这是使用insert方法后的classmates===&#39;,classmates
classmates.pop(0)
print u&#39;这是使用pop（0）之后的classmates===&#39;,classmates
classmates[2]=&#39;abc&#39;
print u&#39;这是使用classmates[2]=abc直接替换后的classmates===&#39;,classmates
print u&#39;也可以这样定义list&#39;,&#39;L=&#39;,[&#39;java&#39;,&#39;python&#39;,[&#39;js&#39;,&#39;php&#39;],&#39;C&#39;]
print u&#39;或者这样定义list&#39;,&#39;lll=&#39;,[&#39;b&#39;,123,False]
print u&#39;要想到php就可以 L[2][1] 就是一个二维数组&#39;
</code></pre>
<hr>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><blockquote>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如：</p>
<pre><code class="python">&gt;&gt;names=(1,2,3)
</code></pre>
<p>现在,names这个tuple不能变了，它也没有<code>append()</code>，<code>insert()</code>,<code>pop()</code>这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用<code>names[0]</code>，<code>names[-1]</code>，但不能赋值成另外的元素。<br>如果你要定义一个只有1个元素的tuple时必须加一个逗号<code>,</code>:</p>
<pre><code class="python">&gt;&gt;p=(1,)
&gt;&gt;p
(1,)
</code></pre>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初学Python&quot;&gt;&lt;a href=&quot;#初学Python&quot; class=&quot;headerlink&quot; title=&quot;初学Python&quot;&gt;&lt;/a&gt;初学Python&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Me" scheme="http://azraa.top/categories/Me/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://azraa.top/2016/12/22/H5%20%E2%91%A1/"/>
    <id>http://azraa.top/2016/12/22/H5 ②/</id>
    <published>2016-12-22T13:19:08.593Z</published>
    <updated>2016-12-22T13:19:08.593Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>星光熠熠</title>
    <link href="http://azraa.top/2016/12/22/%E6%98%9F%E5%85%89%E7%86%A0%E7%86%A0/"/>
    <id>http://azraa.top/2016/12/22/星光熠熠/</id>
    <published>2016-12-21T16:00:00.000Z</published>
    <updated>2016-12-22T12:42:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="星光熠熠"><a href="#星光熠熠" class="headerlink" title="星光熠熠"></a>星光熠熠</h1><p><img src="http://ww3.sinaimg.cn/mw690/9e8603cfgw1fazupgo900j20hs0np74p.jpg" alt=""></p>
<blockquote>
<p>大是一个抽象的词吗？<br>从什么时候开始长？受精卵？胚胎？出生？<br>长到几岁算大？七岁？十一岁？十五岁？十八岁？<br>长大的标准是什么？讲话？走路？上学？工作？成家？<br>可是你总有一个瞬间感觉自己长大了。  </p>
<p>也许是醒来发现自己一个人在黑黑的卧室而不再大哭的时候；<br>也许是每看一遍《简·爱》都有一番全新理解的时候；<br>也许是送走做客的亲戚会笑着说有空再来的时候。<br>你说了以前不会说的话，做了以前不会做的事。<br>这就叫做长大吗？<br>沦落世俗又怎么说呢。  </p>
<p>你直接，简单，容易受伤。<br>你想变得干练，机敏，运筹帷幄。<br>你背井离乡，突出重围，不为利益，只想赚得自己想要的那点儿厉害。<br>你不喜乱笑，偏偏要常投以陌生的笑。<br>你不喜讲话，偏偏不讲话会被人当哑巴。<br>生活，不再是童话世界，也不是数学，万事都有解。<br>过于内关，与世冲突，于人不投，尔弗能悠悠然。<br>未想抵抗，决心顺势而为，终还是迷茫。<br>烟火冷落后，换来的是更寂寞。<br>前后的落差让人心疼，感觉像是做了一场梦，光怪陆离，大跌眼镜，最后捧腹大笑。</p>
<p>夜色如磐。<br>唯有读书不可已。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;星光熠熠&quot;&gt;&lt;a href=&quot;#星光熠熠&quot; class=&quot;headerlink&quot; title=&quot;星光熠熠&quot;&gt;&lt;/a&gt;星光熠熠&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/9e8603cfgw1fazupgo900j20
    
    </summary>
    
      <category term="Bedtime Stories" scheme="http://azraa.top/categories/Bedtime-Stories/"/>
    
    
  </entry>
  
  <entry>
    <title>Vannssi的床边故事 ②</title>
    <link href="http://azraa.top/2016/12/22/Vannssi%E7%9A%84%E5%BA%8A%E8%BE%B9%E6%95%85%E4%BA%8B%E2%91%A1/"/>
    <id>http://azraa.top/2016/12/22/Vannssi的床边故事②/</id>
    <published>2016-12-21T16:00:00.000Z</published>
    <updated>2016-12-22T12:39:04.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><vannssi 2="" 的床边故事=""></vannssi></h1><p><img src="http://ww3.sinaimg.cn/mw690/9e8603cfgw1faztqd15pkj20hs0bhmyb.jpg" alt=""></p>
<blockquote>
<p>最近她的精神状态又不太稳定。<br>已经将近一个月没有过连续四小时以上的睡眠了。<br>总是噩梦，然后惊醒。白天整个人精神涣散。<br>就像六年前一样，颓废，抑郁，恐惧社交，又努力地装出正常人的样子。但大部分时候还是没办法做到，于是趴在桌子上假装睡觉，听着小姑娘们热情的聊着天，直到两颊通红，头昏脑涨，也不愿坐起。<br>她认为这种难受跟尴尬的坐在那里比起来根本不值一提。  </p>
<p>现在她好像又回到了那种样子。<br>已经到了不可以去工作的地步，于是她把工作辞了。<br>每天晚上睡不好，于是所有时间都拿来睡觉。<br>反正也已经没事可做。<br>白天她反倒睡得比任何时候都香，睡不醒，仿佛一睁开眼睛太阳光就能把她刺穿一样。她更像是地狱的受雇者，一到夜晚便要值班，噩梦便是对她不忠的惩罚。<br>男朋友下班了会来看她，给她做饭，陪她说话，强行拉她出去遛弯。<br>我也不知道为什么要用“看”这个字。<br>对她的男朋友，相比于爱来说，她怀有的更多的是一种感激。没有他每天的陪伴，她都不知道自己现在会是什么样子，可能早已沦为地狱全职员工了吧。  </p>
<p>今天晚上结束遛弯后她没有让男朋友走。<br>她说，你可不可以陪陪我，我总是睡不好。<br>他说，好。<br>想来作用也真不小，这一天她出奇的九点钟就睡了。<br>迷迷糊糊间好像有人在呼唤她的名字，她皱了皱眉，眼皮似有千斤重。当她终于战胜这股力量睁开双眼时，又倏地闭上了，反复眨了几次，终于适应这强烈的光线和湛蓝的天。耳边响起清脆的鸟鸣声，鼻腔充斥着花香。她猛地站起来，发现自己刚刚躺在地上，确切的说是悬崖边上。<br>只是眼前迷之惬意的景象让她恍惚了一下，好一派岁月静好，现世安稳啊。但是面前这悬崖的设定是怎么回事？  </p>
<p>她也没想死啊活啊的，此时此刻她只想单纯的跳下去。<br>好像下面有妈妈的嘘寒问暖，有爸爸的全心全意，有奶奶慈爱的目光，有朋友真情的笑容。<br>沉醉在这种感觉里，她迫不及待的伸出了腿。<br>心中一轻，可是身子却一沉。<br>她被人拉住了。<br>抬头看，是她男朋友趴在悬崖上，一只手紧紧地拉着自己，眼泪巴巴的样子像一只乞怜的小狗。<br>“不要走，求你，我爱你。”<br>轰的一声，她的心里仿佛有什么坍塌了，震得她整个人抑制不住抖起来，头也嗡嗡直响。她拼命的摇头，想摆脱这种不适。<br>余光看到悬崖断裂了。<br>原来是真的轰了一声啊。——————  </p>
<p>急剧的下坠。  </p>
<p>猛地蹬了一脚，她醒了。<br>原来是梦吗？<br>赶紧转过身去，看到男朋友就躺在旁边，她悄悄松了一口气。<br>看起来刚睡着的样子，呼吸轻的像羽毛，眉头却紧锁着，就好像刚刚同她在一个梦境中一般。<br>她小心翼翼的伸出手，为他抚平了眉心。  </p>
<p>“放心，一切都会好的。”  </p>
</blockquote>
<p><strong>END.</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;vannssi 2=&quot;&quot; 的床边故事=&quot;&quot;&gt;&lt;/vannssi&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/9e8603c
    
    </summary>
    
      <category term="Bedtime Stories" scheme="http://azraa.top/categories/Bedtime-Stories/"/>
    
    
  </entry>
  
  <entry>
    <title>Something about me</title>
    <link href="http://azraa.top/2016/12/20/Something%20about%20me/"/>
    <id>http://azraa.top/2016/12/20/Something about me/</id>
    <published>2016-12-19T16:00:00.000Z</published>
    <updated>2016-12-21T05:55:36.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Something-about-me"><a href="#Something-about-me" class="headerlink" title="Something about me"></a>Something about me</h1><h2 id="Hi-我是Azraa"><a href="#Hi-我是Azraa" class="headerlink" title="Hi 我是Azraa"></a>Hi 我是Azraa</h2><p><strong>是一个有点呆萌的中二少年  跟大多数宅男爱好差不多 喜欢看动漫 喜欢泡美剧 喜欢睡懒觉 :)</strong></p>
<p><strong>但是我有时又很爱出去玩 只要是朋友组织的娱乐活动都会随叫随到 绝不犹豫的冲进娱乐的吸引圈</strong></p>
<p><strong>我是个超级典型的摩羯座 我想说如果你想问我怎么才能定义典型的摩羯座 如果你对摩羯感兴趣 那么请你先跳到这里</strong><br><em><a href="http://weibo.com/2659582927/EkYqVunGO?from=page_1005052659582927_profile&amp;wvr=6&amp;mod=weibotime&amp;type=comment" target="_blank" rel="external">阿莫学长对摩羯的总结很到位呦~</a></em></p>
<p><strong>如果你认真的看完了 我相信你看完回来会爱上我的:)</strong></p>
<hr>
<h2 id="随性-不同于没脾气-我从来没讲过我是善良的那个"><a href="#随性-不同于没脾气-我从来没讲过我是善良的那个" class="headerlink" title="随性 不同于没脾气 我从来没讲过我是善良的那个"></a>随性 不同于没脾气 我从来没讲过我是善良的那个</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Something-about-me&quot;&gt;&lt;a href=&quot;#Something-about-me&quot; class=&quot;headerlink&quot; title=&quot;Something about me&quot;&gt;&lt;/a&gt;Something about me&lt;/h1&gt;&lt;h2 id=&quot;H
    
    </summary>
    
      <category term="Me" scheme="http://azraa.top/categories/Me/"/>
    
    
  </entry>
  
  <entry>
    <title>Vannssi</title>
    <link href="http://azraa.top/2016/12/19/%E5%85%B3%E4%BA%8EVannssi/"/>
    <id>http://azraa.top/2016/12/19/关于Vannssi/</id>
    <published>2016-12-18T16:00:00.000Z</published>
    <updated>2016-12-22T12:10:37.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vannssi"><a href="#Vannssi" class="headerlink" title="Vannssi"></a>Vannssi</h1><h2 id="Vannssi-是我的一个朋友-女生-天蝎座-天性冷冰冰"><a href="#Vannssi-是我的一个朋友-女生-天蝎座-天性冷冰冰" class="headerlink" title="Vannssi 是我的一个朋友 女生 天蝎座 天性冷冰冰"></a>Vannssi 是我的一个朋友 女生 天蝎座 天性冷冰冰</h2><h2 id="她喜欢弹琴-看书-喜欢画画-喜欢写文-琴棋书画样样都会-不像我-只会玩"><a href="#她喜欢弹琴-看书-喜欢画画-喜欢写文-琴棋书画样样都会-不像我-只会玩" class="headerlink" title="她喜欢弹琴 看书 喜欢画画 喜欢写文 琴棋书画样样都会 不像我 只会玩"></a>她喜欢弹琴 看书 喜欢画画 喜欢写文 琴棋书画样样都会 不像我 只会玩</h2><h2 id="她有一个微信的公众号-专门写下她的奇思妙想-所以从今天起-我会在这里转载她的文"><a href="#她有一个微信的公众号-专门写下她的奇思妙想-所以从今天起-我会在这里转载她的文" class="headerlink" title="她有一个微信的公众号 专门写下她的奇思妙想 所以从今天起 我会在这里转载她的文"></a>她有一个微信的公众号 专门写下她的奇思妙想 所以从今天起 我会在这里转载她的文</h2><h2 id="如果你也喜欢-希望这些奇思妙想能陪着你-度过你开心-孤独-或是无眠的每一天"><a href="#如果你也喜欢-希望这些奇思妙想能陪着你-度过你开心-孤独-或是无眠的每一天" class="headerlink" title="如果你也喜欢 希望这些奇思妙想能陪着你 度过你开心 孤独 或是无眠的每一天"></a>如果你也喜欢 希望这些奇思妙想能陪着你 度过你开心 孤独 或是无眠的每一天</h2><p><strong>那就从床边故事开始吧 因为我最近总在失眠</strong>  </p>
<pre><code>                              &lt;Vannssi 的床边故事 1&gt;
</code></pre><pre><code>  突然她觉得他的背后仿佛有光隐隐闪烁，耀得她眯起了双眼，惊动了心跳。
</code></pre><p><img src="http://ww2.sinaimg.cn/small/9e8603cfgw1faxe7kk99cj20hs0ghmxw.jpg" alt=""></p>
<blockquote>
<p>再加班我就是狗！<br>她一边在脑海里重复这句话，一边拖着好似灌了铅的两条腿向前移动，速度跟分针差不多。可时针还是毫不留情的对上九点。<br>为什么几乎每天都能无所顾忌的说出这句话呢？因为我本来就是啊。<br>恩，单身狗。<br>想到这，肚子也用尽力量表示赞同。<br>妈的。老子从中午十二点之后就没进过食，要饿成照片了。<br>每天加班到很晚的她甚少逛街，甚至都不清楚从地铁口到公司这条路上究竟都开着些什么。只知道有个KFC。<br>那就去KFC吧。</p>
<p>拉开大门让她有种拉开了冰箱门的错觉。<br>呼……这冷气真他妈爽死了。<br>直奔前台点了餐，环顾四周。<br>这个时间客人不多，基本是刚下班的或者学生。恩….坐哪呢？虽然她有选择恐惧症，但她的心理活动一般是这样的：啊，这么多，选这个还是选那个或者是里面那个？哎呀不要再想了好烦就这个吧。<br>于是就近坐在了两个拼在一起的单桌外侧。<br>狼吞虎咽的啃汉堡。平日里偶像包袱重的很，但在这种没有人认识她又能融入人群的地方，几乎不太在意形象。<br>虽然嘴巴动的很快，那是胃的饥饿感在呼唤。但是大脑却在放空，工作很累的啊。</p>
<p>空荡的思绪渐渐回收，从目光落着的地方开始聚焦，发现自己的视线落在一双手上。<br>那手指纤细修长，又不失男人的轮廓感，指甲修理得很整齐，此时正握着手机。<br>啊。真是。好想变成那个手机……<br>仿佛听见了她的心声，男人抬起头来，笑意盈盈。<br>心跳漏了一拍，突然她觉得他的背后仿佛有光隐隐闪烁，耀得她眯起了双眼，惊动了心跳。<br>该死，一开始怎么没发现斜对面做了这么一个极品？</p>
<p>“你在看什么？”</p>
<p>一道慵懒又充盈着笑意的声音仿佛从空中飘落下来，忽远忽近，最终炸裂在她的耳朵里。<br>在跟我说话？愣了一秒，环顾四周确认他是在与她讲话。<br>“啊，我…我在看你那个公仔啊，好可爱哦。”胡乱编了个烂理由，来掩饰自己刚才痴汉般的失态。<br>“这个啊，”他眼帘微垂，好看的手指拿起面前的公仔，大拇指轻轻摩挲着软塑料包装，“是买新出的套餐赠的呢，你喜欢就送你好了。”<br>说罢脸上又浮起温暖的笑容，拿着公仔的手递了过来。不知怎的在她眼里这笑容竟然带有些宠溺。<br>“啊，送我？”她的表情一时有些紧张和尴尬，因为从来不擅长面对男生送的东西。小脸腾地红了，表情倒是自然下来。这没关系，反正是陌生人。<br>随即她也露出了笑容，伸手接过，在两手中把玩。好似还有一股淡淡的青草香，仔细用鼻子嗅了嗅，真的有。他手上的味道。抑制不住心中的喜悦，笑得越发开心起来，小小的酒窝里好像盛满了蜜糖。<br>今天真是美好的一天！<br>这短短十分钟的快乐竟可以把之前十个小时的压抑抹去。<br>她满足的微微闭上双眼。突然白天发生的一切，领导的黑脸和刚刚的温柔笑脸交替在脑海里闪现，交织，轰的在她脑子里炸开。</p>
<p>当她睁开眼睛望向对面时，空无一人。握紧双手只摸到了空气。</p>
<p>鼻腔里残留着炸鸡的油腻味。</p>
<p>九点一刻。</p>
</blockquote>
<p><strong>END.</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vannssi&quot;&gt;&lt;a href=&quot;#Vannssi&quot; class=&quot;headerlink&quot; title=&quot;Vannssi&quot;&gt;&lt;/a&gt;Vannssi&lt;/h1&gt;&lt;h2 id=&quot;Vannssi-是我的一个朋友-女生-天蝎座-天性冷冰冰&quot;&gt;&lt;a href=&quot;#Vanns
    
    </summary>
    
      <category term="Bedtime Stories" scheme="http://azraa.top/categories/Bedtime-Stories/"/>
    
    
  </entry>
  
  <entry>
    <title>初始 H5</title>
    <link href="http://azraa.top/2016/12/18/%E5%88%9D%E8%AF%86H5%20/"/>
    <id>http://azraa.top/2016/12/18/初识H5 /</id>
    <published>2016-12-17T16:00:00.000Z</published>
    <updated>2017-04-23T11:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H5-学习总结"><a href="#H5-学习总结" class="headerlink" title="H5 学习总结"></a>H5 学习总结</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="H5的认识"><a href="#H5的认识" class="headerlink" title="H5的认识"></a>H5的认识</h3><h4 id="H5的概念-能做什么-为什么学习"><a href="#H5的概念-能做什么-为什么学习" class="headerlink" title="H5的概念 能做什么? 为什么学习?"></a>H5的概念 能做什么? 为什么学习?</h4><p><code>HTML5</code>并不仅仅只是做为<code>HTML</code>标记语言的一个最新版本，更重要的是它制定了<code>Web</code>应用开发的一系列标准，成为第一个将<code>Web</code>做为应用开发平台的<code>HTML</code>语言。<br><code>HTML5</code>定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，同时有令人眼花缭乱的<code>css 3</code>，还提供了一些<code>Javascript API</code>，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作<code>webApp</code>，甚至结合<code>Canvas</code>我们可开发网页版游戏。<br>我们日常讨论的<code>H5</code>其实指的是一个泛称，它是由<code>HTML5 + CSS3 + Javascript</code>等技术组合而成的一个应用开发平台。</p>
<h4 id="H5的兼容性"><a href="#H5的兼容性" class="headerlink" title="H5的兼容性"></a>H5的兼容性</h4><p><code>Html5</code>的兼容性（浏览器之间的兼容）<br>兼容性： 新增的部分有兼容性问题（绝大部分）<br>并不是所有的<code>html5</code>都是IE9就兼容的，有一些属性是需要IE10，等更高级的浏览器才能兼容，而<code>html5</code>更多运用在移动端方面，因为移动端搭载的浏览器就比较高级</p>
<h4 id="H5的骨架"><a href="#H5的骨架" class="headerlink" title="H5的骨架"></a>H5的骨架</h4><p> <strong>H5 骨架 是修改部分 没有兼容性问题</strong></p>
<ul>
<li>这是<code>H5</code>的骨架<pre><code class="html">1  &lt;!DOCTYPE html&gt;
2  &lt;html lang=&quot;en&quot;&gt;
3  &lt;head&gt;
4      &lt;meta charset=&quot;UTF-8&quot;&gt;
5      &lt;title&gt;Document&lt;/title&gt;
6  &lt;/head&gt;
7  &lt;body&gt;
8  &lt;/body&gt;
9  &lt;/html&gt;
</code></pre>
</li>
<li>这是原来的 <code>XHTML</code> 的骨架</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>反问：如果在xt的文档DTD里面书写h5的内容，会带来兼容问题么？<br>答：<strong>跟你用什么文档DTD没有关系 主要跟浏览器有关系</strong></p>
<h4 id="HTML的发展历程"><a href="#HTML的发展历程" class="headerlink" title="HTML的发展历程"></a>HTML的发展历程</h4><p>　<br><img src="http://ww4.sinaimg.cn/small/9e8603cfgw1faxe7k3dz0j20en06gaaa.jpg" alt="发展流程"></p>
</blockquote>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="Html5-中新添的标签"><a href="#Html5-中新添的标签" class="headerlink" title="Html5 中新添的标签"></a>Html5 中新添的标签</h3><p>新增的6大结构标签：</p>
<p>（1）<code>header</code><br>（2）<code>nav</code><br>（3）<code>section</code><br>（4）<code>aside</code><br>（5）<code>article</code><br>（6）<code>footer</code><br>（7）<code>audio</code><br>（8）<code>canvas</code><br>（9）<code>command</code><br>（10）<code>datalist</code></p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;头部&lt;/header&gt;
    &lt;nav&gt;导航&lt;/nav&gt;
    &lt;section&gt;区块&lt;/section&gt;
    &lt;aside&gt;侧边栏&lt;/aside&gt;
    &lt;article&gt;文章页&lt;/article&gt;
    &lt;footer&gt;页脚&lt;/footer&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>作用：跟div一模一样 ，就是增加了语义性 更加利于seo优化</strong></p>
<p>还有一些不太常用的新增标签</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
     &lt;audio&gt; 标签定义声音，比如音乐或其他音频流。
HTML5:&lt;audio src=&quot;someaudio.wav&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;
HTML4:&lt;object type=&quot;application/ogg&quot; data=&quot;someaudio.wav&quot;&gt;&lt;param name=&quot;src&quot; value=&quot;someaudio.wav&quot;&gt;&lt;/object&gt;

     &lt;canvas&gt; 标签定义图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。
HTML5:&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;
HTML4:&lt;object data=&quot;inc/hdr.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/object&gt;

     &lt;command&gt; 标签定义命令按钮，比如单选按钮、复选框或按钮。
HTML5: &lt;command onclick=cut()&quot; label=&quot;cut&quot;&gt;
HTML4: none

     &lt;datalist&gt; 标签定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。
HTML5: &lt;datalist&gt;&lt;/datalist&gt;
HTML4: see combobox.

     &lt;details&gt; 标签定义元素的细节，用户可进行查看，或通过点击进行隐藏。与 &lt;legend&gt; 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。
HTML5: &lt;details&gt;&lt;/details&gt;
HTML4: &lt;dl style=&quot;display:hidden&quot;&gt;&lt;/dl&gt;

     &lt;embed&gt; 标签定义嵌入的内容，比如插件。
HTML5: &lt;embed src=&quot;horse.wav&quot; /&gt;
HTML4: &lt;object data=&quot;flash.swf&quot;  type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;

     &lt;figcaption&gt; 标签定义 figure 元素的标题。”figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。
HTML5: &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;/figure&gt;
HTML4: none

&lt;figure&gt; 标签用于对元素进行组合。使用 &lt;figcaption&gt; 元素为元素组添加标题。
HTML5: &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;p&gt;The People&#39;s Republic of China was born in 1949...&lt;/p&gt;&lt;/figure&gt;
HTML4: &lt;dl&gt;&lt;h1&gt;PRC&lt;/h1&gt;&lt;p&gt;The People&#39;s Republic of China was born in 1949...&lt;/p&gt;&lt;/dl&gt;

     &lt;hgroup&gt; 标签用于对网页或区段（section）的标题进行组合。
HTML5: &lt;hgroup&gt;&lt;/hgroup&gt;
HTML4: &lt;div&gt;&lt;/div&gt;

     &lt;keygen&gt; 标签定义生成密钥。
HTML5: &lt;keygen&gt;
HTML4: none

     &lt;mark&gt;主要用来在视觉上向用户呈现那些需要突出的文字。&lt;mark&gt;标签的一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。
HTML5: &lt;mark&gt;&lt;/mark&gt;
HTML4: &lt;span&gt;&lt;/span&gt;

     &lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。
HTML5: &lt;meter&gt;&lt;/meter&gt;
HTML4: none

     &lt;output&gt; 标签定义不同类型的输出，比如脚本的输出。
HTML5: &lt;output&gt;&lt;/output&gt;
HTML4: &lt;span&gt;&lt;/span&gt;

     &lt;progress&gt; 标签运行中的进程。可以使用 &lt;progress&gt; 标签来显示 JavaScript 中耗费时间的函数的进程。
HTML5: &lt;progress&gt;&lt;/progress&gt;
HTML4: none

     &lt;rp&gt; 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。
HTML5: &lt;ruby&gt;漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt;
HTML4: none

     &lt;rt&gt; 标签定义字符（中文注音或字符）的解释或发音。
HTML5: &lt;ruby&gt;漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt;&lt;/ruby&gt;
HTML4: none

     &lt;ruby&gt; 标签定义 ruby 注释（中文注音或字符）。
HTML5: &lt;ruby&gt;漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt;
HTML4: none

     &lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。
HTML5: &lt;source&gt;
HTML4: &lt;param&gt;

     &lt;summary&gt; 标签包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。”summary” 元素应该是 “details” 元素的第一个子元素。
HTML5: &lt;details&gt;&lt;summary&gt;HTML 5&lt;/summary&gt;This document teaches you everything you have to learn about HTML 5.&lt;/details&gt;
HTML4: none

     &lt;time&gt; 标签定义日期或时间，或者两者。
HTML5: &lt;time&gt;&lt;/time&gt;
HTML4: &lt;span&gt;&lt;/span&gt;

     &lt;video&gt; 标签定义视频，比如电影片段或其他视频流。
HTML5: &lt;video src=&quot;movie.ogg&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;
HTML4:&lt;object type=&quot;video/ogg&quot; data=&quot;movie.ogv&quot;&gt;&lt;param name=&quot;src&quot; value=&quot;movie.ogv&quot;&gt;&lt;/object&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="由于html5新增的标签有兼容问题，所以我们需要做兼容！怎么实现？"><a href="#由于html5新增的标签有兼容问题，所以我们需要做兼容！怎么实现？" class="headerlink" title="由于html5新增的标签有兼容问题，所以我们需要做兼容！怎么实现？"></a>由于html5新增的标签有兼容问题，所以我们需要做兼容！怎么实现？</h4><ol>
<li>利用document.creatElement()去创建html5的新标签，同时设置成块元素（相对麻烦）<pre><code class="javascript">&lt;!--[if lt IE 9]&gt;   
         &lt;script type=&quot;text/javascript&quot;&gt;
           var e = &quot;abbr, article, aside, audio, canvas, 
datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, 
menu, meter, nav, output, progress, section, time, video&quot;.split(&#39;, &#39;);
           var i= e.length;
          while (i--){
                document.createElement(e[i])
          }  
      &lt;/script&gt;
   &lt;![endif]--&gt;
</code></pre>
</li>
<li>借助于第三方的JS框架 =&gt;html5shiv.min.js （推荐）配合IE的hack实现最佳兼容<pre><code class="Javascript">&lt;!--[if lt IE 9]&gt; 
    &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;H5-学习总结&quot;&gt;&lt;a href=&quot;#H5-学习总结&quot; class=&quot;headerlink&quot; title=&quot;H5 学习总结&quot;&gt;&lt;/a&gt;H5 学习总结&lt;/h1&gt;&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="H5的概念与新增标签" scheme="http://azraa.top/categories/H5%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>高级 JavaScript (二)</title>
    <link href="http://azraa.top/2016/10/28/%E9%AB%98%E7%BA%A7JavaScript%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://azraa.top/2016/10/28/高级JavaScript（二）/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2016-12-18T16:04:29.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级-JavaScript-（二）"><a href="#高级-JavaScript-（二）" class="headerlink" title="高级 JavaScript （二）"></a>高级 JavaScript （二）</h1><h2 id="闭包的练习"><a href="#闭包的练习" class="headerlink" title="闭包的练习"></a>闭包的练习</h2><h3 id="for循环中注册点击事件"><a href="#for循环中注册点击事件" class="headerlink" title="for循环中注册点击事件"></a>for循环中注册点击事件</h3><h3 id="for循环中是用setTimeout"><a href="#for循环中是用setTimeout" class="headerlink" title="for循环中是用setTimeout"></a>for循环中是用setTimeout</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存就是将一些数据，资源，进行临时的存储，以提高访问效率</p>
<p>浏览器缓存<br>CDN<br>JS中的缓存</p>
<h2 id="使用缓存解决斐波那契数列的性能问题"><a href="#使用缓存解决斐波那契数列的性能问题" class="headerlink" title="使用缓存解决斐波那契数列的性能问题"></a>使用缓存解决斐波那契数列的性能问题</h2><h3 id="有什么性能问题"><a href="#有什么性能问题" class="headerlink" title="有什么性能问题"></a>有什么性能问题</h3><p>使用递归去计算斐波那契数列存在大量的重复的计算，导致计算效率十分低下</p>
<h3 id="如何解决性能问题"><a href="#如何解决性能问题" class="headerlink" title="如何解决性能问题"></a>如何解决性能问题</h3><p>使用缓存</p>
<pre><code class="js">//1.创建一个数组充当缓存容器
var arr = [];

function fibnacci(n){
//2.每次需要计算斐波那契数字的时候，先去缓存中进行查找
    var num = arr[n];
    if(num){
         //3.如果有就直接返回
        return num;
    }else{
        //4.如果没有，就去就算，算出来结果之后，
        if(n &lt;= 2){
            num = 1;
        }else{
            num = fibnacci(n-1)+fibnacci(n-2);
        }
        //5.将结果存入缓存中
        arr[n] = num;
        //6.将结果返回
        return num;
    }

}
</code></pre>
<pre><code class="js">function createFib(){
    //1.创建一个数组充当缓存容器
    var arr = [];
    function fibnacci(n){
    //2.每次需要计算斐波那契数字的时候，先去缓存中进行查找
        var num = arr[n];
        if(!num){
            //4.如果没有，就去就算，算出来结果之后，
            if(n &lt;= 2){
                num = 1;
            }else{
                num = fibnacci(n-1)+fibnacci(n-2);
            }
            //5.将结果存入缓存中
            arr[n] = num;
        }
        //6.将结果返回
        return num;
    }
    return fibnacci;
}
</code></pre>
<h2 id="jQuery缓存实现分析"><a href="#jQuery缓存实现分析" class="headerlink" title="jQuery缓存实现分析"></a>jQuery缓存实现分析</h2><pre><code class="js">function createCache(){
    //需要一个能够存储数据的容器
    var cache = {};

    //用存储键，并且记录键存入的顺序
    var keys = [];
    return function(key, value){
        if(value){
            cache[key] = value;
            keys.push(key);

            if(keys.length &gt; 50){
                delete cache[keys.shift()];
            }

        }else{
            return cache[key];
        }
    }
}
</code></pre>
<h2 id="jQuery缓存源码分析"><a href="#jQuery缓存源码分析" class="headerlink" title="jQuery缓存源码分析"></a>jQuery缓存源码分析</h2><pre><code class="js">function createCache(){
    var keys = [];
    function cache(key, value){
        if(keys.push(key + &quot; &quot;) &gt; 10){
            delete cache[keys.shift()];
        }
        return (cache[key + &quot; &quot;] = value);
    }
    return cache;
}

var cache = createCache();
cache(&quot;name&quot;,&quot;Li2Dog&quot;);
cache[&quot;name&quot; + &quot; &quot;];
</code></pre>
<h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><p>形式：函数名();<br>this:window</p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><p>形式：对象名.方法名();<br>this: 调用该方法的对象</p>
<h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><p>形式：new 函数名()<br>this: new创建出来的对象</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code class="js">function createPerson(){
    var o = new Object();
    o.name = &quot;zs&quot;;
    o.age = 18;
    return o;
}

var p = createPerson();
</code></pre>
<h4 id="寄生模式"><a href="#寄生模式" class="headerlink" title="寄生模式"></a>寄生模式</h4><pre><code class="js">function Person(){
    var o = new Object();
    o.name = &quot;zs&quot;;
    o.age = 18;
    return o;
}

var p = new Person();
</code></pre>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>在其他的调用模式中，this不可以赋值，也就不能改变<br>在上下文调用模式中，可以进行手动的设置this的值。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre><code class="js">函数名.call(对象, 参数1, 参数2, 参数3...)
</code></pre>
<ol>
<li>调用函数</li>
<li>将函数内的this指向第一个参数中的对象</li>
<li>将除第一个参数外的所有参数依次传给函数，做为实参<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="js">函数名.apply(对象, 数组)
</code></pre>
</li>
<li>调用函数</li>
<li>将函数内的this指向第一个参数中的对象</li>
<li>将第二个参数中的数组拆解开，将数组中的元素依次的传给函数当做实参</li>
</ol>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><pre><code class="js">function Parent(){
    this.money = 100000000000000;
}

function Son(){
    Parent.call(this);
    this.wife = &quot;凤姐&quot;;
}

var s = new Son();
</code></pre>
<ol>
<li>使用new关键字创建了一个对象</li>
<li>调用构造函数Son，将Son中的this指向刚才创建的对象</li>
<li>在Son构造函数中，是用上下文调用模式去调用Parent函数，</li>
<li>调用Person函数，将Parent中的this指向song中的this，也就是用new创建出来的那个对象</li>
<li>Parent中会使用this给对象添加成员</li>
<li>Parent调用结束，Son中的this也就有了Parent中添加的那些个成员</li>
</ol>
<p>将伪数组转换成数组</p>
<pre><code class="js">var fakeArr = {
    0:&quot;a&quot;,
    1:&quot;b&quot;,
    2:&quot;c&quot;,
    length:3
}

var arr = [];

Array.prototype.push.apply(arr, fakeArr);
Array.prototype.concat.apply(arr, fakeArr);


arr.concat.apply(arr, fakeArr);
</code></pre>
<p>求数组的最大值</p>
<pre><code class="js">var arr = [1 ,2,3,3,4,4,34,3,43,43,43,4,34,3];

var max = Math.max.apply(null, arr);
//Math.max(1,2,3,43,4,3,43,43,43)
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级-JavaScript-（二）&quot;&gt;&lt;a href=&quot;#高级-JavaScript-（二）&quot; class=&quot;headerlink&quot; title=&quot;高级 JavaScript （二）&quot;&gt;&lt;/a&gt;高级 JavaScript （二）&lt;/h1&gt;&lt;h2 id=&quot;闭包的练习
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>高级 JavaScript (一)</title>
    <link href="http://azraa.top/2016/10/27/%E9%AB%98%E7%BA%A7JavaScript%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://azraa.top/2016/10/27/高级JavaScript（一）/</id>
    <published>2016-10-26T16:00:00.000Z</published>
    <updated>2016-12-21T05:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级-JavaScript-一"><a href="#高级-JavaScript-一" class="headerlink" title="高级 JavaScript (一)"></a>高级 JavaScript (一)</h1><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><h3 id="词法作用域的概念"><a href="#词法作用域的概念" class="headerlink" title="词法作用域的概念"></a>词法作用域的概念</h3><pre><code>变量的作用域在代码写好的时候就已经可以确定，这种作用域就是词法作用域
</code></pre><ul>
<li>JavaScript中没有动态作用域</li>
<li>JavaScript中没有块级作用域</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><pre><code>JS代码执行分两个阶段，首先进行预解析，再执行

在预解析阶段，系统会将所有的变量声明以及函数声明提升到当前作用域的最顶上
</code></pre><ul>
<li>当函数同名的时候，都会提升，但是后面的函数会将前面的函数覆盖</li>
<li>当函数和变量同名的时候，只会提升函数声明，变量声明会被忽略</li>
<li>变量提升是分作用域的</li>
<li>变量提升是分段（script标签）</li>
<li>函数表达式是不会被提升,提升的只是变量的声明。  var func= function(){};</li>
<li>条件式函数声明，根据浏览器不同，提升的情况不同，最新的浏览器中都不会进行提升</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><pre><code>在js中只有函数可以限定作用域，然后，函数中又可以声明函数，这样就形成了一个由内向外进行访问的链式结构，这个结构就叫做作用域链
</code></pre><h3 id="如何绘制作用域链"><a href="#如何绘制作用域链" class="headerlink" title="如何绘制作用域链"></a>如何绘制作用域链</h3><ol>
<li>先画一条直线，表示0级作用域链，也就是全局作用域</li>
<li>再在全局作用域中查找变量以及函数的声明，将所有找到的这些成员以小方块的形式放在0级作用域链上</li>
<li>如果全局作用域中有函数成员，那就从该函数中在引出一条线，表示1级作用域链</li>
<li>再去1级作用域中进行查找变量以及函数的声明，在把他们画出来，<br>5、如果还有函数，就接着去找。。。。直到没有函数为止</li>
</ol>
<h3 id="变量的搜索原则"><a href="#变量的搜索原则" class="headerlink" title="变量的搜索原则"></a>变量的搜索原则</h3><p>1、首先在当前作用域中进行查找，如果找到了就直接使用<br>2、如果没有找到，就去上一级作用域中进行查找，如果找到了就直接使用<br>3、如果没有找到，就继续往上查找，直到找到全局作用域为止</p>
<h3 id="如何分析面试题"><a href="#如何分析面试题" class="headerlink" title="如何分析面试题"></a>如何分析面试题</h3><ol>
<li>先进行提升处理（把提升后的代码写出来）</li>
<li>然后根据作用域及作用域链还有变量搜索原则进行分析</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>语文解释：封闭的包裹结构</li>
<li>js的解释：函数就是一个闭包</li>
</ul>
<h3 id="闭包要解决的问题是什么？"><a href="#闭包要解决的问题是什么？" class="headerlink" title="闭包要解决的问题是什么？"></a>闭包要解决的问题是什么？</h3><p>函数内部的数据无法被外界直接访问！</p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>在函数内部返回一个函数，用来操作该函数内部的数据。</p>
<h3 id="闭包的原理（作用域）"><a href="#闭包的原理（作用域）" class="headerlink" title="闭包的原理（作用域）"></a>闭包的原理（作用域）</h3><p>函数中的变量无法被上一级作用域访问，但是可以被下一级作用域访问。</p>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><pre><code class="js">function func(){
    var name = &quot;&quot;;
    return function(){
        return name;
    }
}
</code></pre>
<h3 id="如何访问多个数据？"><a href="#如何访问多个数据？" class="headerlink" title="如何访问多个数据？"></a>如何访问多个数据？</h3><p>返回一个对象，对象中包含对所有数据的设置和访问的方法，在函数外部接收到该对象之后，就可以操作函数内部的数据</p>
<h3 id="点击事件的注册问题"><a href="#点击事件的注册问题" class="headerlink" title="点击事件的注册问题"></a>点击事件的注册问题</h3><p>如果在for循环中使用循环的控制变量i来处理点击事件中的内容，那么这个i在点击事件触发的时候，循环已经结束，i已经变成了最后一个值，所以会不准去</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>在点击事件的处理函数内部，访问的时候，不要去使用i，而是使用这个函数自己的一个私有的数据。<br>所以需要使用一个拥有自己的变量的函数来做点击事件的处理函数。</p>
<p>这个函数需要通过闭包来创建。</p>
<pre><code class="js">function f1(j){
    return function(){
        console.log(j);  //这里的j就是只有这个函数可以访问的一个私有的变量
    }
}
</code></pre>
<p>上面的函数调用之后的返回值，就拥有了自己独立的变量，我们可以使用它来做点击事件的处理函数</p>
<h3 id="setTimeout的回调函数执行时间问题"><a href="#setTimeout的回调函数执行时间问题" class="headerlink" title="setTimeout的回调函数执行时间问题"></a>setTimeout的回调函数执行时间问题</h3><p>setTimeout和setInterval中的回调函数，会在所有的主逻辑代码执行完之后，才依次检查执行时间是不是到了，到了就会执行</p>
<p>当把setTimeout放在一个for循环语句中的时候，如果在回调函数中使用了循环中变量i<br>那么，当setTimeout的回调函数执行的时候，for循环已经执行完毕，i已经是最后一个值</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>回调函数不应该去使用for循环中的i，而是使用自己的一个私有变量</p>
<pre><code class="js">function f(j){
    return fucntion(){
        console.log(j)
    }
}
setTimeout(f(i),0);
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级-JavaScript-一&quot;&gt;&lt;a href=&quot;#高级-JavaScript-一&quot; class=&quot;headerlink&quot; title=&quot;高级 JavaScript (一)&quot;&gt;&lt;/a&gt;高级 JavaScript (一)&lt;/h1&gt;&lt;h2 id=&quot;词法作用域&quot;&gt;&lt;a
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象（三）</title>
    <link href="http://azraa.top/2016/10/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://azraa.top/2016/10/15/面向对象（三）/</id>
    <published>2016-10-14T16:00:00.000Z</published>
    <updated>2016-12-18T16:02:26.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h1><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><pre><code>1. 原型中的属性
2. 是在构造函数创建出来的时候，系统创建原型的时候，默认的让原型中的constructor属性指向构造函数本身
3. 这个属性基本用不到
</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><pre><code>1.现在对象本身中进行查找，如果找到了就直接使用
2.如果没有，就去原型中查找，如果找到了就直接使用
3.如果没有找到，就去原型的原型中查找，以此往复，直到找到null
</code></pre><h3 id="Array-prototype-是一个空数组"><a href="#Array-prototype-是一个空数组" class="headerlink" title="Array.prototype 是一个空数组"></a>Array.prototype 是一个空数组</h3><p>//arr—-&gt;Array.prototype—–&gt;Object.Prototype—–&gt;null<br>var arr = [];</p>
<h2 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h2><pre><code class="js">对象  instanceof 构造函数
//返回值为boolean类型
//功能： 判断构造函数的原型是不是在该对象的原型链上
</code></pre>
<h2 id="Object-prototype的成员"><a href="#Object-prototype的成员" class="headerlink" title="Object.prototype的成员"></a>Object.prototype的成员</h2><ul>
<li>constructor 原型中的属性指向和原型相关的构造函数</li>
<li>hasOwnProperty<pre><code class="js">对象.hasOwnProperty(属性名)
//返回值为boolean类型
//功能：判断属性是否存在对象本身中
</code></pre>
</li>
<li>isPrototypeOf<pre><code class="js">对象.isPrototypeof(对象1)
//返回值为boolean
//功能：判断对象是否是对象1的原型对象
</code></pre>
</li>
<li>propertyIsEnumerable<pre><code class="js">对象.propertyIsEnumberable(属性名)
//返回值为boolean
//功能：判断属性是否属于对象本身并且能够被遍历（for-in）
</code></pre>
</li>
<li><p>toString toLocaleString<br>  都是将对象转换成字符串类型<br>  toLocaleString会将字符串转换成本地格式的字符串， 本地格式为系统设置</p>
</li>
<li><p>valueOf<br>  在对象参与运算的时候，会首先调用valueOf方法，如果获取到的值能够参与运算就直接使用，<br>  如果不能参与运算，就调用toString方法<br>  []==![] true<br>  {}==!{} false</p>
</li>
</ul>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code>用来创建函数的
</code></pre><ul>
<li>如果不传参数，创建出来的是空函数</li>
<li>如果传一个参数，创建出来的时候有函数体，但是没有形参的函数</li>
<li>如果传多个参数，最后参数会被作为函数体，之前所有的参数都会被作为形参</li>
</ul>
<p>可以把字符串转换成代码</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><pre><code>也可以将字符串转换成代码并且执行
</code></pre><h3 id="Function和eval的区别"><a href="#Function和eval的区别" class="headerlink" title="Function和eval的区别"></a>Function和eval的区别</h3><pre><code>* Funtion创建出来的是函数，函数需要手动调用，里面的代码才会执行
* eval直接回将字符串转换成代码，并且执行
</code></pre><h3 id="Function和eval的共同点"><a href="#Function和eval的共同点" class="headerlink" title="Function和eval的共同点"></a>Function和eval的共同点</h3><pre><code>* 都可以将字符串转换成代码
* 都不安全
</code></pre><h3 id="eval处理JSON格式字符串的时候"><a href="#eval处理JSON格式字符串的时候" class="headerlink" title="eval处理JSON格式字符串的时候"></a>eval处理JSON格式字符串的时候</h3><pre><code>* 会把JSON格式字符串中的{}当做代码段来处理，所以会报错
* 处理方式两种
    * 给JSON字符串前后拼接小括号()
    * 将变量的声明以及等号 拼接在JSON格式字符串的前面
</code></pre><h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><ul>
<li>静态成员：通过构造函数去访问的成员就是静态成员</li>
<li>实例成员：通过实例去访问的成员就是实例成员</li>
</ul>
<h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><p>arguments对象是函数中的一个对象，在函数调用的时候，会将所有传入的实参依次存入该对象</p>
<ul>
<li>length  获取传入实参的个数</li>
<li>callee  指向函数本身   匿名函数的递归</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象（三）&quot;&gt;&lt;a href=&quot;#面向对象（三）&quot; class=&quot;headerlink&quot; title=&quot;面向对象（三）&quot;&gt;&lt;/a&gt;面向对象（三）&lt;/h1&gt;&lt;h2 id=&quot;constructor属性&quot;&gt;&lt;a href=&quot;#constructor属性&quot; class
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象（二）</title>
    <link href="http://azraa.top/2016/10/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://azraa.top/2016/10/07/面向对象（二）/</id>
    <published>2016-10-06T16:00:00.000Z</published>
    <updated>2016-12-18T16:02:26.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象-（二）"><a href="#面向对象-（二）" class="headerlink" title="面向对象 （二）"></a>面向对象 （二）</h1><h2 id="面向对象编程举例"><a href="#面向对象编程举例" class="headerlink" title="面向对象编程举例"></a>面向对象编程举例</h2><h3 id="1-面向过程的思维方式"><a href="#1-面向过程的思维方式" class="headerlink" title="1.面向过程的思维方式"></a>1.面向过程的思维方式</h3><pre><code>代码重复性太高，几乎没有复用性。
</code></pre><h3 id="2-使用函数进行封装"><a href="#2-使用函数进行封装" class="headerlink" title="2.使用函数进行封装"></a>2.使用函数进行封装</h3><pre><code>提升的代码的复用性
全局变量污染
结构混乱，后期维护不便
</code></pre><h3 id="3-使用对象进行封装"><a href="#3-使用对象进行封装" class="headerlink" title="3.使用对象进行封装"></a>3.使用对象进行封装</h3><pre><code>使用对象进行封装，在外界之暴露一个对象名，不会造成全局污染
在对象内部使用对象的属性，进行模块的划分，让代码的结构更加的清晰，便于维护
</code></pre><h2 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h2><h3 id="字面量创建对象"><a href="#字面量创建对象" class="headerlink" title="字面量创建对象"></a>字面量创建对象</h3><pre><code class="js">var obj = {
    key: value,
    key: value
}
</code></pre>
<p>只能创建一次对象，复用性太差</p>
<h3 id="内置构造函数创建对象"><a href="#内置构造函数创建对象" class="headerlink" title="内置构造函数创建对象"></a>内置构造函数创建对象</h3><pre><code class="js">var obj = new Object();
</code></pre>
<p>每次创建出来的对象都是空对象，需要手动的去添加成员</p>
<h3 id="自定义构造函数创建对象"><a href="#自定义构造函数创建对象" class="headerlink" title="自定义构造函数创建对象"></a>自定义构造函数创建对象</h3><p>自己创建的构造函数就是自定构造函数</p>
<h2 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h2><h3 id="构造函数的特点"><a href="#构造函数的特点" class="headerlink" title="构造函数的特点"></a>构造函数的特点</h3><ul>
<li>函数的首字母大写</li>
<li>一般和new关键字配合使用</li>
<li>没有return语句，返回值默认为创建出来的对象<ul>
<li>手动添加return语句的时候</li>
<li>如果return的是基本类型的数据，则不会对默认的返回有任何的影响</li>
<li>如果return的是对象类型的数据，则会替换掉默认的返回值</li>
</ul>
</li>
</ul>
<h3 id="构造函数的执行步骤"><a href="#构造函数的执行步骤" class="headerlink" title="构造函数的执行步骤"></a>构造函数的执行步骤</h3><ul>
<li>使用new关键字创建对象</li>
<li>调用构造函数，将this赋值为new关键字创建出来的对象</li>
<li>在构造函数中，使用this为新创建的对象新增成员</li>
<li>默认返回新创建的这个对象</li>
</ul>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><pre><code>将数据和方法进行封装，对外界只提供指定的接口，外部使用只要调用相应的接口，而不需要关心内部的具体实现
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承
</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>JS中没有多态
父类的指针指向子类的对象
</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="构造函数存在的问题"><a href="#构造函数存在的问题" class="headerlink" title="构造函数存在的问题"></a>构造函数存在的问题</h3><pre><code>如果将方法的定义写在构造函数中，每次创建对象的时候，都会重新的创建一个新的方法，每个对象独占一个方法，但是所有对象的该方法都是一样的，会造成资源浪费
</code></pre><ul>
<li>在外部声明函数，每次创建对象的时候，将外部的函数引用赋值给当前对象的方法，这样就能保证所有的对象都指向构造函数外部的这个函数</li>
<li>使用原型<h3 id="原型是什么"><a href="#原型是什么" class="headerlink" title="原型是什么"></a>原型是什么</h3>  在构造函数创建出来的时候，系统会默认的为构造函数创建并关联一个空对象，这个的对象就是原型</li>
</ul>
<h3 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a>原型的作用</h3><pre><code>所用通过构造函数创建出来的对象，都能访问原型中的成员，也就是说原型中的成员被所有的对象共享
</code></pre><h3 id="如何访问原型对象"><a href="#如何访问原型对象" class="headerlink" title="如何访问原型对象"></a>如何访问原型对象</h3><ul>
<li>构造函数.prototype</li>
<li>对象.<strong>proto</strong> (不推荐使用，因为有兼容性问题，调试的时候可以使用)</li>
</ul>
<h3 id="原型的使用方式"><a href="#原型的使用方式" class="headerlink" title="原型的使用方式"></a>原型的使用方式</h3><ul>
<li>利用对象的动态特性为原型添加成员</li>
<li>直接替换原型对象</li>
</ul>
<h3 id="原型的使用注意事项"><a href="#原型的使用注意事项" class="headerlink" title="原型的使用注意事项"></a>原型的使用注意事项</h3><ul>
<li>一般情况只将方法放在原型中，属性放在对象中</li>
<li>对象在获取属性的时候，会现在自身查找，如果找到了直接使用，如果没有找到，就去原型中查找，如果找到了就使用</li>
<li>对象在设置属性的时候，不会去原型中查找了，只在自身进行查找，如果找到了，就修改，如果没有找到，就新增</li>
<li>在替换原型对象的时候，需要注意：替换之前创建的对象和替换之后创建的对象的原型不一致</li>
</ul>
<h2 id="继承的实现方式"><a href="#继承的实现方式" class="headerlink" title="继承的实现方式"></a>继承的实现方式</h2><h3 id="混入式继承（mix-in）"><a href="#混入式继承（mix-in）" class="headerlink" title="混入式继承（mix-in）"></a>混入式继承（mix-in）</h3><pre><code class="js">var obj = {};
var obj1 = {name:&quot;adsf&quot;,age:18};
for(var k in obj1){
    obj[k] = obj1[k];
}
</code></pre>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><h4 id="1-使用混入的方式为原型对象添加成员、"><a href="#1-使用混入的方式为原型对象添加成员、" class="headerlink" title="1.使用混入的方式为原型对象添加成员、"></a>1.使用混入的方式为原型对象添加成员、</h4><pre><code class="js">var human = {name:&quot;&quot;,age:18}
function Person(){};

for(var k in human){
    Person.prototype[k] = human[k];
}
</code></pre>
<h4 id="2-直接修改原型对象"><a href="#2-直接修改原型对象" class="headerlink" title="2.直接修改原型对象"></a>2.直接修改原型对象</h4><pre><code class="js">function Person(){}
Person.prototype.name = &quot;&quot;;
Person.prototype.age = 18;
</code></pre>
<h4 id="3-替换原型对象"><a href="#3-替换原型对象" class="headerlink" title="3.替换原型对象"></a>3.替换原型对象</h4><pre><code class="js">var human = {name:&quot;&quot;,age:18}
function Person(){};
Person.prototype = human;
</code></pre>
<h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><pre><code class="js">var obj = Object.create(obj1);
//创建出来一个新的对象obj继承自obj1
//原理就是把obj1设置为obj的原型
</code></pre>
<h4 id="经典继承的兼容性问题"><a href="#经典继承的兼容性问题" class="headerlink" title="经典继承的兼容性问题"></a>经典继承的兼容性问题</h4><pre><code class="js">function myCreate(obj){
    //判断浏览器有没有Object.create方法
    if(Object.create){
        //如果有，直接调用
        return Object.create(obj);
    }else{
        function F(){}
        F.prototype = obj;
        return new F();
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象-（二）&quot;&gt;&lt;a href=&quot;#面向对象-（二）&quot; class=&quot;headerlink&quot; title=&quot;面向对象 （二）&quot;&gt;&lt;/a&gt;面向对象 （二）&lt;/h1&gt;&lt;h2 id=&quot;面向对象编程举例&quot;&gt;&lt;a href=&quot;#面向对象编程举例&quot; class=&quot;head
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象（一）</title>
    <link href="http://azraa.top/2016/10/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://azraa.top/2016/10/04/面向对象（一）/</id>
    <published>2016-10-03T16:00:00.000Z</published>
    <updated>2016-12-18T16:02:27.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h1><h2 id="JavaScript基础知识复习"><a href="#JavaScript基础知识复习" class="headerlink" title="JavaScript基础知识复习"></a>JavaScript基础知识复习</h2><p>在学习高级对象之前应该熟练的使用JS 下面是一些JS的基本知识</p>
<h3 id="JavaScript的基本组成"><a href="#JavaScript的基本组成" class="headerlink" title="JavaScript的基本组成"></a>JavaScript的基本组成</h3><pre><code>* ECMAScript     规定了JavaScript的语法规范
* DOM            提供了访问页面元素的API
* BOM            提供了访问浏览器相关信息的API
</code></pre><h3 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h3><h4 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h4><pre><code>* string
* number
* boolean
* undefined
</code></pre><h4 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h4><pre><code>* Object
* function
* Array
* Date
* RegExp
* Math（对象）
* String
* Number
* Boolean
* null(特殊的)
</code></pre><h4 id="获取类型的关键字-typeof"><a href="#获取类型的关键字-typeof" class="headerlink" title="获取类型的关键字 typeof"></a>获取类型的关键字 typeof</h4><pre><code class="js">typeof 变量名（表达式）
//返回值为字符串类型
</code></pre>
<h4 id="引用类型-值类型"><a href="#引用类型-值类型" class="headerlink" title="引用类型 值类型"></a>引用类型 值类型</h4><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><pre><code>存储的是数据的地址的数据就是引用类型的数据
</code></pre><h5 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h5><pre><code>存储的数据本身的数据就是值类型的数据
</code></pre><h5 id="赋值特征"><a href="#赋值特征" class="headerlink" title="赋值特征"></a>赋值特征</h5><pre><code>* 值类型进行赋值的时候，直接将数据复制一份赋值给新的变量，两份数据互不影响
* 引用类型进行赋值的时候，将数据的地址复制一份赋值给新的变量，两个变量指向同一个对象，两个互相影响
</code></pre><h3 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h4><pre><code>用来遍历对象的属性的，每次遍历到的属性是字符串类型的
```js
    for(var k in obj){
        //这里的k就是每个键
    }
```
</code></pre><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><pre><code>检测对象中是否存在某个属性
```js
属性名 in 对象名
```
</code></pre><h3 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a>逻辑中断</h3><h4 id=""><a href="#" class="headerlink" title="||"></a>||</h4><pre><code>表达式1 || 表达式2
如果表达式1为真，就返回表达式1，如果表达式1位假，则返回表达式2
</code></pre><h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><pre><code>表达式1 &amp;&amp; 表达式2
如果表达式1为真，就返回表达式2，如果表达式1位假，则返回表达式1
</code></pre><h3 id="delete关键字"><a href="#delete关键字" class="headerlink" title="delete关键字"></a>delete关键字</h3><pre><code>* 删除未使用var声明的变量
* 删除对象的属性
* `window`有自带的属性`name`
</code></pre><h3 id="continue-break"><a href="#continue-break" class="headerlink" title="continue break"></a>continue break</h3><pre><code>* continue 跳出本次循环，继续下次循环
* break 跳出整个循环，继续执行循环之后的代码
</code></pre><h3 id="对象的动态特性"><a href="#对象的动态特性" class="headerlink" title="对象的动态特性"></a>对象的动态特性</h3><pre><code>对象在创建出来之后，可以随时的新增成员（方法和属性），这就是对象的动态特性
</code></pre><h3 id="最后作为开发人员需要知道的基本的调试工具的使用"><a href="#最后作为开发人员需要知道的基本的调试工具的使用" class="headerlink" title="最后作为开发人员需要知道的基本的调试工具的使用"></a>最后作为开发人员需要知道的基本的调试工具的使用</h3><pre><code>* 普通断点
* 条件断点

 Elements  审查元素 做css
* Console  跟页面在同一个js的运行环境中，可以写任何的js代码，也可以用js操作页面元素
* Sources  所有的资源文件都在这里，最重要的就是可以在这里对js代码进行断点调试
</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code class="js">try{
    //可能出现异常的代码
}catch(e){
    //e 异常对象，异常信息
    //捕获异常后的处理代码
}finally{
    //不论是否发生异常，都会执行的代码
}
</code></pre>
<h2 id="面向对象简单介绍"><a href="#面向对象简单介绍" class="headerlink" title="面向对象简单介绍"></a>面向对象简单介绍</h2><h3 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h3><pre><code>面向对象是一种思维方式，他是将解决问题的关注点放到了解决问题所需要的一些列对象身上
</code></pre><h3 id="面向过程的基本概念"><a href="#面向过程的基本概念" class="headerlink" title="面向过程的基本概念"></a>面向过程的基本概念</h3><pre><code>面向过程是一种思维方式，他是将解决问题的关注点放到了解决问题的每一个详细的步骤上
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象（一）&quot;&gt;&lt;a href=&quot;#面向对象（一）&quot; class=&quot;headerlink&quot; title=&quot;面向对象（一）&quot;&gt;&lt;/a&gt;面向对象（一）&lt;/h1&gt;&lt;h2 id=&quot;JavaScript基础知识复习&quot;&gt;&lt;a href=&quot;#JavaScript基础知识复习&quot;
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象整体概括</title>
    <link href="http://azraa.top/2016/10/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B4%E4%BD%93%E6%A6%82%E6%8B%AC/"/>
    <id>http://azraa.top/2016/10/02/面向对象整体概括/</id>
    <published>2016-10-01T16:00:00.000Z</published>
    <updated>2016-12-18T16:03:52.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象整体概括"><a href="#面向对象整体概括" class="headerlink" title="面向对象整体概括"></a>面向对象整体概括</h1><h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><h3 id="面向对象和面向过程分别是什么？"><a href="#面向对象和面向过程分别是什么？" class="headerlink" title="面向对象和面向过程分别是什么？"></a>面向对象和面向过程分别是什么？</h3><pre><code>都是思维方式.
面向过程的思维方式是将解决问题的关注点放在解决问题的每一个详细步骤上。
面向对象的思维方式是将解决问题的关注点放在解决问题所需要的一系列对象上。

面向对象其实就是对面向过程封装
</code></pre><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><pre><code>万物皆对象
JavaScript中的对象就是无序键值对儿的集合
</code></pre><h3 id="什么是属性什么是方法"><a href="#什么是属性什么是方法" class="headerlink" title="什么是属性什么是方法"></a>什么是属性什么是方法</h3><pre><code>JavaScript对象中，如果键对应的值是数据，那么这个键就称为属性
                 如果键对应的值是函数，那么这个键就称为方法
</code></pre><h3 id="名词提炼法"><a href="#名词提炼法" class="headerlink" title="名词提炼法"></a>名词提炼法</h3><pre><code>在一个句子中，只要是名词就可以把他看做一个对象，这种提炼对象的方式就叫名词提炼法
</code></pre><h2 id="面向对象编程举例"><a href="#面向对象编程举例" class="headerlink" title="面向对象编程举例"></a>面向对象编程举例</h2><ol>
<li>使用面向过程的思维方式去考虑问题，写出来的代码存在如下问题：<ul>
<li>代码复用性太差</li>
<li>结构混乱</li>
<li>全局污染</li>
</ul>
</li>
<li>使用函数进行封装，解决复用性的问题，但又出现以下问题<ul>
<li>全局污染</li>
<li>代码结构混乱</li>
</ul>
</li>
<li>使用对象进行封装，解决了以上所有问题</li>
</ol>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>在面向对象程序设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。同时，它也是一种防止外界调用端，去访问对象内部实现细节的手段，这个手段是由编程语言本身来提供的。这两个概念有一些不同，但通常被混合使用。封装被视为是面向对象的四项原则之一。<br>  适当的封装，可以将对象使用接口的程序实现部分隐藏起来，不让用户看到，同时确保用户无法任意更改对象内部的重要数据。它可以让代码更容易理解与维护，也加强了代码的安全性</p>
</blockquote>
<p>将数据和行为全部封装到对象内，实现一些功能，给外界提供一些接口，外界在使用功能的时候只需要通过接口来调用，而不需要关系对象内部的具体实现，这就是封装</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。</p>
</blockquote>
<p>一个对象没有某些属性和方法，另外一个对象有，拿过来用，就是继承</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>JS中没有多态<br>父类指针指向子类对象</p>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h3><pre><code class="js">var obj = {
    key:value,
    key:value,
    key:value
};
</code></pre>
<p>通过字面量创建对象，每次创建的对象都只能当次使用，下次如果还要使用，就得再写一次，复用性差。</p>
<h3 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h3><pre><code class="js">var obj = new Object();
</code></pre>
<p>每次创建的对象都是空的对象，都得去手动的添加成员，所以也有复用性问题</p>
<h3 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h3><pre><code class="js">function Person(){
    this.name = &quot;li2Dog&quot;;
    this.age = 18;
}

var p = new Person();
</code></pre>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数的概念"><a href="#构造函数的概念" class="headerlink" title="构造函数的概念"></a>构造函数的概念</h3><pre><code>构造函数也是一个函数，和普通函数不同的地方在于，构造函数是用来初始化对象的。
</code></pre><h3 id="构造函数的特征"><a href="#构造函数的特征" class="headerlink" title="构造函数的特征"></a>构造函数的特征</h3><ul>
<li>首字母大写</li>
<li>通常和new关键字配合使用</li>
<li>不需要写return语句，默认返回新创建的对象</li>
<li>如果手动写了return语句<ul>
<li>如果是值类型的数据，则对返回值没有任何的影响</li>
<li>如果是引用类型的数据，则替换掉默认的返回值</li>
</ul>
</li>
</ul>
<h3 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h3><ol>
<li>先使用<code>new</code>关键字创建对象</li>
<li>调用构造函数，将<code>this</code>指针赋值为新创建出来的对象</li>
<li>在构造函数内部，使用<code>this</code>为新创建出来的对象新增成员</li>
<li>默认的返回新创建出来的对象</li>
</ol>
<h3 id="如果将构造函数当做普通函数来调用"><a href="#如果将构造函数当做普通函数来调用" class="headerlink" title="如果将构造函数当做普通函数来调用"></a>如果将构造函数当做普通函数来调用</h3><ul>
<li>函数内部的<code>this</code>指向了<code>window</code></li>
<li>返回值默认的为<code>undefined</code></li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><p>构造函数在创建出来的时候，系统会默认的给构造函数创建并关联一个空的对象，这个对象就是原型</p>
<h3 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a>原型的作用</h3><p>原型中的成员可以被何其关联的构造函数所创建出来的所有的对象共享</p>
<h3 id="原型的访问形式"><a href="#原型的访问形式" class="headerlink" title="原型的访问形式"></a>原型的访问形式</h3><pre><code class="js">构造函数.prototype
对象.__proto__   非标准属性，有兼容性问题
</code></pre>
<h3 id="原型的使用方式"><a href="#原型的使用方式" class="headerlink" title="原型的使用方式"></a>原型的使用方式</h3><ul>
<li>利用动态特性为原型对象添加属性和方法</li>
<li>直接替换原型对象</li>
</ul>
<h3 id="原型的使用注意事项"><a href="#原型的使用注意事项" class="headerlink" title="原型的使用注意事项"></a>原型的使用注意事项</h3><ol>
<li>一般情况下将方法放在原型对象中，将属性放在对象中</li>
<li>在获取属性的时候，需要遵守属性搜索原则</li>
<li>在设置属性的时候，不需要遵守属性搜索原则</li>
<li>在替换原型对象的时候，替换之前创建的对象的原型和替换之后创建的对象的原型不一致</li>
</ol>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="混入式继承（mix-in）"><a href="#混入式继承（mix-in）" class="headerlink" title="混入式继承（mix-in）"></a>混入式继承（mix-in）</h3><pre><code class="js">var obj = {};
var obj1 = {
    name:&quot;周三&quot;,
    age:18
};
for(var k in obj1){
    obj[k] = obj1[k];
}
</code></pre>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>1.使用混入的方式给原型对象添加属性和方法</p>
<pre><code class="js">function Person(){}
var parentObj = {
    name : &quot;周天儿&quot;,
    age : 7
};
for(var k in parentObj){
    Person.prototype[k] = parentObj[k];
}
var p = new Person();
</code></pre>
<ol>
<li>直接修改原型对象<br>```js<br>function Person(){}</li>
</ol>
<p>Person.prototype.name = “”;<br>Person.prototype.age = 18;</p>
<p>var p = new Person();</p>
<pre><code>3. 替换原型对象
```js
function Person(){}

Person.prototype = {
    name : &quot;周天儿&quot;,
    age : 7
};

var p = new Person();
</code></pre><h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><pre><code class="js">var parentObj = {
    name : &quot;周天儿&quot;,
    age : 7
};
//创建一个继承自parentObj的对象obj
var obj = Object.create(parentObj);
</code></pre>
<p>原理：原型继承</p>
<p>兼容性问题解决(内置对象不可以随便修改)</p>
<pre><code class="js">function myCreate(obj){
    if(Object.create){
        return Object.create(obj);
    }else{
        function F(){}
        F.prototype = obj;
        return new F();
    }
}
</code></pre>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每一个对象都有原型，每一个原型都是对象，每一个原型也都有原型，就形成了链式结构，称为原型链</p>
<ol>
<li>首先画构造函数</li>
<li>在画原型对象</li>
<li>换出构造函数和原型对象的关系</li>
<li>画出实例</li>
<li>滑出实例和构造函数以及原型的关系</li>
<li>把原型多做对象，找出原型的构造函数</li>
<li>从第一步重复</li>
</ol>
<h2 id="Object-prototype的成员"><a href="#Object-prototype的成员" class="headerlink" title="Object.prototype的成员"></a>Object.prototype的成员</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>属性，用来指向和原型相关的构造函数，可配置</td>
</tr>
<tr>
<td>hasOwnProper</td>
<td>方法，用来检测属性是否存在对象本身</td>
</tr>
<tr>
<td>isPrototypeOf</td>
<td>方法，用来检测对象是否另外一个对象的原型</td>
</tr>
<tr>
<td>propertyIsEnumerable</td>
<td>方法，用来检测属性是否属于对象本身，并且能否被遍历</td>
</tr>
<tr>
<td>toString</td>
<td>方法，将对象转换为字符串，Object.toString方法默认的返回值[object 构造函数名]</td>
</tr>
<tr>
<td>toLocaleString</td>
<td>方法，将对象转换为本地格式的字符串，本地格式为系统设置</td>
</tr>
<tr>
<td>valueOf</td>
<td>方法，当对象参与运算的时候，会默认的调用valueOf方法获取对象的值，如果可以参与运算，则直接使用，如果不能，则调用toString方法</td>
</tr>
<tr>
<td><strong>proto</strong></td>
<td>属性，指向对象的原型</td>
</tr>
</tbody>
</table>
<h2 id="Function-eval"><a href="#Function-eval" class="headerlink" title="Function eval"></a>Function eval</h2><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>可以使用Function来创建函数，他可以将字符串转换成代码</p>
<pre><code class="js">//如果不传参数，则创建出来的是空函数
var func = new Function();
//如果传一个参数，则这个参数为函数体
var func1 = new Function(methodBody);
//如果传多个参数，则最后一个参数为函数体，之前所有参数为函数的形参名
var func2 = new Function(arg1, arg2, arg3, arg4, argN, methodBody);
</code></pre>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>可以将字符串转换成代码并且运行</p>
<p>当使用<code>eval</code>处理JSON格式字符串的时候，会将JSON字符串内的<code>{}</code>当做代码段来处理，会报错</p>
<p>解决方案：</p>
<ul>
<li>在JSON格式的字符串前后拼接<code>()</code></li>
<li>将变量的声明(<code>var obj</code>)和<code>=</code>拼接在JSON格式的字符串之前</li>
</ul>
<h3 id="eval和Function的区别和联系"><a href="#eval和Function的区别和联系" class="headerlink" title="eval和Function的区别和联系"></a>eval和Function的区别和联系</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>都可以将字符串转换成代码</li>
<li>都存在安全性问题</li>
<li>都存在性能问题</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>Funciton创建出来的是函数，需要手动的去调用</li>
<li>eval直接会将字符串转成代码进行执行</li>
</ul>
<h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><p>静态成员：通过构造函数访问的成员是静态成员<br>实例成员：通过对象访问的成员是实例成员</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象整体概括&quot;&gt;&lt;a href=&quot;#面向对象整体概括&quot; class=&quot;headerlink&quot; title=&quot;面向对象整体概括&quot;&gt;&lt;/a&gt;面向对象整体概括&lt;/h1&gt;&lt;h2 id=&quot;面向对象的基本概念&quot;&gt;&lt;a href=&quot;#面向对象的基本概念&quot; class=&quot;he
    
    </summary>
    
      <category term="高级JavaScript" scheme="http://azraa.top/categories/%E9%AB%98%E7%BA%A7JavaScript/"/>
    
    
  </entry>
  
</feed>
